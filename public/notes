
Created the domain
created the certificate

Steps:
1 - retirar o restart:allways e colocar o depends on
  jenkins:
    build:
      context: './build/jenkins'
#    restart: always
    ports:
      - "8891:8080"
      - "50000:50000"
    volumes:
      - jenkins-data:/var/jenkins_home
    depends_on:
      - kill-50000

 o depends_on kill-50000

   kill-50000:
     image: alpine:latest
     command: ["sh", "-c", "fuser -k 50000/tcp"]






Um serviço chamado kill-50000 é definido com uma imagem Alpine Linux. Esse serviço tem a única finalidade de executar um comando (fuser -k 50000/tcp) que mata qualquer processo que esteja utilizando a porta 50000 no contexto desse contêiner.

O serviço principal, chamado jenkins, depende do serviço kill-50000. Isso significa que antes do Jenkins iniciar, o Docker Compose garante que o serviço kill-50000 seja executado para liberar a porta 50000.

O comando fuser -k 50000/tcp dentro do contêiner kill-50000 é projetado para matar qualquer processo que esteja utilizando a porta 50000 dentro do próprio contêiner. Isso significa que ele não está matando processos na máquina host onde o Docker Compose é executado, nem em qualquer outro contêiner.

Quando você executa docker-compose up, o Docker Compose cria um contêiner temporário chamado kill-50000 com base na imagem Alpine Linux. Dentro desse contêiner, o comando fuser -k 50000/tcp é executado, o que encerra qualquer processo que esteja utilizando a porta 50000 dentro desse contêiner.

Essa estratégia é usada para garantir que, antes de iniciar o serviço jenkins, a porta 50000 dentro do contêiner temporário kill-50000 seja liberada. Assim, quando o serviço jenkins for iniciado, ele pode usar a porta 50000 sem problemas.

Resumindo, o comando está matando processos apenas dentro do contêiner kill-50000 e não afeta processos fora desse contexto ou na máquina host.





criar um serviço para collocar o jenkins up and running a cada reboot. Explicar e meter docs

Serviço RC (Systemd): ( https://ciksiti.com/pt/chapters/4313-how-to-use-etc-rc-local-at-boot--linux-hint )

To add services or scripts at startup, you need to create a systemd unit .
Systemd units include services (.service ) , mount points ( .mount ), devices (.device ) , or sockets (.outlet ) . Unlike the old process described earlier with rc.local, instead of editing the same file containing information about user scripts, you need to create a Systemd service unit for each script you want to run at startup.

Systemd units are located in /etc/systemd/system , and that's where we need to create the systemd unit for the script we want to run at startup.

Systemd is a service manager that assigns service control groups (cgroup) and tracks processes. Systemd is the process (PID) 1 responsible for system initialization.

nano /etc/systemd/system/rc-local.service
colocar:
    a) sudo nano /etc/rc.local:
        [Unit]
        Description=<Script name or description>

        [Service]
        ExecStart=/bin/bash -c "cd /home/jgomes/my/jgomes && docker-compose up -d --build jenkins"
        WorkingDirectory=/home/jgomes/my/jgomes

        [Install]
        WantedBy=multi-user.target


 sudo systemctl daemon-reload - ( Needed case we need to do sn update in the file )
 sudo systemctl enable rc-local
 sudo systemctl start rc-local
reboot

dps fazer o vhost com proxy para expor para o exterior o jenkins ( https://www.youtube.com/watch?v=E3_g5wYZlfk )

vhost

LoadModule headers_module modules/mod_headers.so

<IfModule mod_ssl.c>
        LoadModule proxy_module modules/mod_proxy.so
        <VirtualHost *:443>

                ServerAdmin zx.gomes@gmail.com
                ServerName jjenkins.xyz
                ErrorLog /var/log/apache2/jenkins_error.log
                CustomLog ${APACHE_LOG_DIR}/jenkins_access.log combined
                SSLEngine on
                SSLCertificateFile /home/jgomes/my/jgomes/cert/jenkins.crt
                SSLCertificateKeyFile /home/jgomes/my/jgomes/cert/jenkins.key
                SSLCertificateChainFile /home/jgomes/my/jgomes/cert/jenkins.ca-bundle

		ProxyRequests Off
		ProxyPass / http://localhost:8891/ nocanon
		ProxyPassReverse / http://localhost:8891/

		RequestHeader set X-Forwarded-Proto "https"
		RequestHeader set X-Forwarded-Port "443"

	        <Location />
	           Order allow,deny
		   Allow from all
		   AllowOverride all
	        </Location>

        </VirtualHost>
</IfModule>

Make Jenkins running at jjenkins.xyz pelo primeira vez

copiar a chave dos los para a primeira instalaçao
meter os dados
instalar os pluggins default
Installed on Jenkins the github pluggin <br>
Instale o Plugin GitHub:

Acesse o Jenkins e vá para "Manage Jenkins" > "Manage Plugins".
Na guia "Available", pesquise por "GitHub" e instale o plugin "GitHub multibranvn" ou similar.

Instalar o ssh Agent para criar cretenciais seguras
Entrar no no container do jenkins:
Criar par de chaves
Copiar a public
Ir ao servidor e criar uma authorize keys e colocar a publica
Dps voltar ao container do jenkins e copiar a privada
No jenkins Criar uma credencial ssh e meter la chave privada

Dps criar um new item
dar um nome e seleccionar um multibranvn pipeline

la dentro:
dar um nome
criar um source selecionando o "git"
Project Repository:https://github.com/jfgomes/site-jgomes.git
Credentials: user/pass
Property strategy:All branches get the same properties

seleccionar Scan by webhook e dar um nome que vai ser o token: jgomes
dps ir ao github e criar um webhook (no param token colocar a criado no jenkins:
https://jjenkins.xyz/multibranch-webhook-trigger/invoke?token=jgomes

por fim na raiz do project criar um Jenkinsfile:
pipeline {
    agent any
    stages {
        stage('Checkout') {
            steps {
               echo 'Do the checkout from the repo and put the code i this context.'
               checkout scm
            }
        }
        stage('Build') {
            steps {
                // mandatory as I want to run unit tests using the phpunit from vendor
                echo 'Run composer'
                sh 'composer update'
                // .env file is mandatory to generate app key
                echo 'Copy .env file'
                sh 'cp .env.example .env'
                // app key is mandatory to run tests
                echo 'Generate application key'
                sh 'php artisan key:generate'
            }
        }
        stage('Tests') {
            steps {
                echo 'Run tests'
                sh 'vendor/bin/phpunit'
            }
        }
        stage('Deploy') {
            when {
                // only deploy to prod if master - || env.BRANCH_NAME.startsWith('feature/')
                expression {
                    return (env.BRANCH_NAME == 'master')
                }
            }
            steps {
                script {
                    sshagent(credentials: ['c44a8a0c-8686-470d-b0de-fbbb19ba86ad']) {

                        // do deploy
                        sh 'ssh -o StrictHostKeyChecking=no jgomes@94.63.32.148 \'cd /home/jgomes/my/jgomes/site && git pull origin master \''

                        // do composer update, migration, and clean the cache
                        sh 'ssh -o StrictHostKeyChecking=no jgomes@94.63.32.148 \'cd /home/jgomes/my/jgomes/site && composer update && php artisan config:clear \''

                        // restore composer.lock from repo as the composer update done before generates the same file as is on repo, creating also a modified file that will block the next pull on the next pipeline
                        sh 'ssh -o StrictHostKeyChecking=no jgomes@94.63.32.148 \'cd /home/jgomes/my/jgomes/site && git restore composer.lock \''
                    }
                }
            }
        }
    }
}
este jenkis file tem:
        stage('Checkout') puxa o codigo que esta no repo para o context do jenkins
        stage('Build') Faz o setup do projecto neste context ja qu vido do repo é como se fosse um projecto virgem sem nenhum setup
        stage('Tests') corre os testes
        stage('Deploy') faz o deploy caso a branch seja a master ( se nao for igona este step )
        se for master é preciso usar um sshagent (pluggin criado no iniciar) e usa a credeciar q é a cave privada do jenkins ( criada unteriormente tb)
        la dentro faço:
         - um git pull origin master
         -  composer update
          - limpo a cache com php artisan config:clear
          - corro as alteraçoes de db: migrate
         - faço um git restore composer.lock para o composer.lock ficar igual ao repo. Aqui fica mudificado porque corro composer update e é gerando sempre um ficheiro que fica untracted. se for limpo o proximo pull nao vai funcionar uma  vez que existe esta alteraçao


